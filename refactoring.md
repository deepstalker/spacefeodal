# План рефакторинга проекта SpaceFeodal

## 1. Архитектурные изменения

### 1.1. Разделение ответственностей в StarSystemScene

В текущей реализации `StarSystemScene` выполняет слишком много задач: инициализация, управление игровыми объектами, обработка ввода, отрисовка и игровая логика. Необходимо разделить эти обязанности.

**Задачи:**

- **Вынос логики инициализации**:
  - Создать сервис `SystemInitializer` (`src/services/SystemInitializer.ts`).
  - Перенести логику создания звезды, планет (включая орбитальное движение), POI и станций из `StarSystemScene.create()` (строки ~70-200) в `SystemInitializer`.
  - `SystemInitializer` должен получать `scene`, `config` и `fogOfWar` как зависимости.
  - `StarSystemScene` будет вызывать `systemInitializer.init()` в своем `create()`.

- **Вынос логики обновления**:
  - Создать сервис `GameUpdateManager` (`src/services/GameUpdateManager.ts`).
  - Перенести регистрацию обработчиков `UPDATE` из `StarSystemScene` (например, строки ~370-400, где вызываются различные `update` методы) в `GameUpdateManager`.
  - `GameUpdateManager` будет координировать вызов методов обновления для других систем (например, `movement.update(delta)`, `combat.update(delta)`).
  - `StarSystemScene` будет создавать и инициализировать `GameUpdateManager`, а не регистрировать свои обработчики `UPDATE`.

- **Вынос логики отрисовки**:
  - Создать компонент `StarfieldRenderer` (`src/components/StarfieldRenderer.ts`).
  - Перенести метод `drawStarfield` из `StarSystemScene` в `StarfieldRenderer`.
  - `StarfieldRenderer` должен получать `scene` и `config` как зависимости.
  - Аналогично, создать `AimLineRenderer` (`src/components/AimlineRenderer.ts`) и перенести логику `drawAimLine`.
  - `StarSystemScene` будет создавать эти рендереры и вызывать их методы отрисовки в нужные моменты.

### 1.2. Упрощение системы управления NPC

В проекте существует дублирование логики управления NPC между `NPCMovementManager`, `NPCStateManager` и `CombatManager`. Необходимо объединить эту логику.

**Задачи:**

- **Объединение логики**:
  - Создать единый сервис `NPCManager` (`src/services/NPCManager.ts`).
  - `NPCManager` будет отвечать за:
    -   Создание NPC (возможно, инкапсулируя часть логики из `CombatManager.spawnNPCPrefab`).
    -   Управление состоянием NPC (взяв на себя функции `NPCStateManager`).
    -   Управление движением NPC (взяв на себя функции `NPCMovementManager` и используя `MovementManager` для расчетов).
    -   Обновление поведения NPC в цикле `UPDATE`.
  - `CombatManager` должен быть пересмотрен, чтобы он делегировал управление NPC сервису `NPCManager`.

- **Упрощение системы состояний**:
  - Проанализировать `NPCStateManager` и определить, можно ли упростить систему состояний, убрав сложные механизмы остывания агрессии, если они вносят излишнюю сложность для текущих потребностей.
  - Рассмотреть возможность использования более простой конечной машины состояний для NPC.

- **Единая точка управления движением**:
  - Убрать прямую зависимость `CombatManager` от `NPCMovementManager`.
  - Заменить это на взаимодействие с `NPCManager`.
  - `MovementManager` может остаться как вспомогательный класс для расчетов, используемый внутри `NPCManager`.

### 1.3. Улучшение системы ввода

Логика обработки ввода (правая кнопка мыши, радиальное меню) реализована непосредственно в `StarSystemScene`, что делает код менее модульным.

**Задачи:**

- **Вынос обработки ввода**:
  - Создать сервис `InputHandler` (`src/services/InputHandler.ts`).
  - Перенести логику обработки кликов мыши, удержания, перетаскивания камеры из `StarSystemScene` в `InputHandler`.
  - `InputHandler` должен использовать `InputManager` для подписки на события, но сам обрабатывать логику этих событий.
  - `InputHandler` будет эмитить собственные игровые события (например, 'player-move-command', 'radial-menu-triggered') через систему событий Phaser (`scene.events.emit`).

- **Модульность радиального меню**:
  - Перенести логику из `RadialMenuManager` (`src/ui/RadialMenuManager.ts`) в компонент `RadialMenuComponent` (`src/components/RadialMenuComponent.ts`), чтобы лучше соответствовать паттерну компонента.
  - Создать сервис `RadialMenuHandler` (`src/services/RadialMenuHandler.ts`).
  - `RadialMenuHandler` будет подписываться на событие 'radial-menu-triggered' от `InputHandler` и на события выбора пункта меню от `RadialMenuComponent`.
  - Он будет координировать отображение меню и выполнение команд, передавая команды (например, установка цели движения) в другие сервисы (например, `MovementManager`).

## 2. Улучшение структуры кода

### 2.1. Организация компонентов

В проекте отсутствует четкая структура для компонентов. Необходимо ввести более строгую организацию.

**Задачи:**

- **Создание папки components**:
  - Создать папку `src/components`.
  - Перенести туда существующие визуальные компоненты и рендереры:
    - `src/ui/RadialMenuManager.ts` -> `src/components/RadialMenuComponent.ts` (с переименованием класса).
    - `src/ui/hud/HUDManager.ts` -> `src/components/HUDComponent.ts` (с переименованием класса).
    - Создать `src/components/StarfieldRenderer.ts`, `src/components/AimlineRenderer.ts`.
  - Обновить пути импортов во всех файлах, где используются эти компоненты.

- **Группировка сервисов**:
  - Создать папку `src/services`.
  - Добавить новые сервисы-обёртки для разгрузки сцен:
    - `src/services/StarfieldRenderer.ts` — многослойный фон (звёзды/небулы) + случайный starfield.
    - `src/services/SystemInitializer.ts` — инициализация звезды, планет, POI, регистрация в FOW.
    - `src/services/SystemLoaderService.ts` — загрузка активной звёздной системы (static/procedural).
    - `src/services/PlanetOrbitManager.ts` — обновление орбит планет, проксирование _x/_y в конфиг.
    - `src/services/EncounterManager.ts` — активация POI/баннеры/очистка маркеров.
    - `src/services/InputHandler.ts` — ПКМ/радиальное меню/команды движения игрока.
    - `src/services/NPCBehaviorManager.ts` — поведения NPC (торговцы/патруль) с делегированием в CombatManager.
    - `src/services/PathRenderService.ts` — отрисовка линии цели и пользовательского пути.
    - `src/services/GameUpdateManager.ts` — единая точка подписки на UPDATE и политика паузы.
  - Обновить пути импортов.

- **Модульность сцен**:
  - После переноса логики в `src/services` и `src/components`, `StarSystemScene` должен:
    - Создавать экземпляры сервисов.
    - Передавать необходимые зависимости (например, `scene`, `config`, другие сервисы) в конструкторы сервисов.
    - Подписываться на события от сервисов/компонентов, если это необходимо для координации.
    - Вызывать методы сервисов/компонентов в своих методах `create`, `update` и т.д.
  - `UIScene` аналогично должна координировать работу UI-компонентов (`HUDComponent`, `RadialMenuComponent`).

### 2.2. Управление зависимостями

В текущей реализации компоненты напрямую зависят друг от друга, что затрудняет тестирование и модификацию.

**Задачи:**

- **Внедрение зависимостей**:
  - Изменить конструкторы сервисов и компонентов так, чтобы они принимали свои зависимости в качестве параметров, а не создавали их внутри.
  - Например, `CombatManager` должен получать `scene`, `config`, `pauseManager` через конструктор, а не создавать их или получать через `this.scene`.
  - Это позволит легче подменять зависимости в тестах и уменьшит связность.

- **Интерфейсы для сервисов**:
  - Создать интерфейсы для основных сервисов в `src/types/` или рядом с ними.
    - `IConfigManager.ts`, `ICombatManager.ts`, `IMovementManager.ts`, `INPCManager.ts`, `IGameUpdateManager.ts` и т.д.
    - Интерфейсы должны объявлять основные методы и свойства сервисов.
  - Классы сервисов должны реализовывать эти интерфейсы (`class CombatManager implements ICombatManager`).
  - Другие классы должны зависеть от интерфейсов, а не от конкретных классов. Например, `StarSystemScene` будет иметь свойства типа `ICombatManager`, `IConfigManager` и т.д., которым будут присваиваться экземпляры конкретных классов при инициализации.

## 3. Улучшение читаемости и поддержки кода

### 3.1. Комментирование кода

В коде практически отсутствуют комментарии, объясняющие сложные алгоритмы или архитектурные решения.

**Задачи:**

- **Комментарии к алгоритмам**:
  - Добавить комментарии к методу `getAimedTargetPoint` в `CombatManager`, объясняющие логику предсказания положения цели.
  - Добавить комментарии к сложным частям `NPCStateManager`, объясняющим систему приоритетов и состояний.
  - Комментировать сложные математические расчеты в `MovementManager`.

- **Архитектурные комментарии**:
  - Добавить комментарии в заголовки файлов сервисов и компонентов, объясняющие их назначение и основные обязанности.
  - Добавить комментарии в `StarSystemScene` и `UIScene`, объясняющие, как они координируют работу других модулей.

### 3.2. Улучшение именования

Некоторые переменные и методы имеют неочевидные имена, что затрудняет понимание кода.

**Задачи:**

- **Уточнение имен**:
  - Переименовать `npcSim` в `StarSystemScene` в `npcLazySimulationManager` для ясности.
  - Проверить другие неоднозначные имена переменных и методов по всему проекту и при необходимости переименовать их.

- **Единообразие**:
  - Убедиться, что имена переменных и методов следуют единому стилю по всему проекту (например, camelCase для переменных, PascalCase для классов).

### 3.3. Удаление неиспользуемого кода

В проекте есть закомментированный код и неиспользуемые методы.

**Задачи:**

- **Очистка кода**:
  - Удалить все закомментированные фрагменты кода, которые не планируется использовать (например, отладочные `console.log` и закомментированные блоки в `NPCLazySimulationManager`).

- **Удаление неиспользуемых методов**:
  - Проверить, используется ли метод `getRenderPathPoints` в `MovementManager`. Если нет, удалить его.

## 4. Оптимизация производительности

### 4.1. Обработка событий UPDATE

В `StarSystemScene` зарегистрировано множество обработчиков `UPDATE`, что может негативно сказаться на производительности.

**Задачи:**

- **Консолидация обработчиков**:
  - После создания `GameUpdateManager`, убедиться, что все обработчики `UPDATE` перенесены туда, и `StarSystemScene` больше не регистрирует свои собственные обработчики `UPDATE` для игровой логики.

- **Оптимизация условий**:
  - Проверить, можно ли оптимизировать условия внутри обработчиков, чтобы избежать ненужных вычислений.

### 4.2. Управление объектами

При увеличении количества NPC и объектов на сцене могут возникнуть проблемы с производительностью.

**Задачи:**

- **Объектный пул**:
  - Внедрить объектный пул для часто создаваемых/уничтожаемых объектов, таких как снаряды и эффекты попадания.

- **Фрустум кulling**:
  - Реализовать отсечение объектов, находящихся вне видимой области камеры, для уменьшения нагрузки на отрисовку.

## 5. Улучшение системы конфигурации

### 5.1. Типизация конфигураций

В `ConfigManager` определены типы для конфигураций, но они не везде используются должным образом.

**Задачи:**

- **Строгая типизация**:
  - Убедиться, что все конфигурации строго типизированы и используются в коде соответствующим образом.

- **Валидация конфигураций**:
  - Добавить валидацию загружаемых конфигураций на этапе инициализации, чтобы избежать ошибок во время выполнения.

### 5.2. Централизованное управление настройками

Настройки разбросаны по разным конфигурационным файлам.

**Задачи:**

- **Единый доступ к настройкам**:
  - Создать сервис `SettingsService`, который будет предоставлять централизованный доступ ко всем настройкам игры.

- **Горячая перезагрузка**:
  - Реализовать возможность горячей перезагрузки настроек без перезапуска игры для упрощения настройки и тестирования.

## 6. Улучшение системы сохранений

### 6.1. Расширяемость

Текущая реализация `SaveManager` ограничена только сохранением состояния игрока.

**Задачи:**

- **Гибкая система сохранений**:
  - Расширить `SaveManager` для поддержки сохранения состояния различных игровых систем (NPC, станции, задания и т.д.).

- **Версионирование сохранений**:
  - Добавить систему версионирования сохранений для обеспечения совместимости при обновлениях игры.

## 7. Улучшение системы ввода

### 7.1. Гибкость

Система ввода жестко привязана к мыши и клавиатуре.

**Задачи:**

- **Поддержка различных устройств**:
  - Расширить `InputManager` для поддержки других устройств ввода, таких как геймпады.

- **Настраиваемые привязки**:
  - Реализовать систему настраиваемых привязок клавиш/кнопок для улучшения пользовательского опыта.

## 8. Улучшение системы отладки

### 8.1. Инструменты разработчика

В проекте есть некоторые отладочные функции, но их недостаточно.

**Задачи:**

- **Расширение отладочных возможностей**:
  - Добавить больше инструментов для отладки, таких как визуализация путей NPC, отображение состояний, инструменты для манипуляции объектами в реальном времени.

- **Консоль разработчика**:
  - Реализовать консоль разработчика с возможностью выполнения команд и просмотра состояния игры.

## Заключение

Рефакторинг проекта позволит значительно улучшить его архитектуру, читаемость и поддерживаемость. Основное внимание следует уделить разделению ответственностей, упрощению сложных систем и улучшению структуры кода. Это создаст прочную основу для дальнейшего развития проекта и облегчит добавление новых функций.